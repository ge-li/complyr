#' Data generating process: propensity score
#'
#' Generates the covariates and the propensity scores. The propensity scores are
#' generated by
#' `ps = stats::make.link(ps_link)$linkinv(eta_0 + eta_1 * x1 + eta_2 * x2 + eta_3 * x1_t + eta_4 * x2_t)`.
#'
#' @param n numeric Number of samples (observations).
#' @param x1_dist character {"binary", "uniform", "normal"}.
#' @param x2_dist character {"binary", "uniform", "normal"}.
#' @param sigma_x numeric Standard deviation of x (if not binary).
#' @param nonlinearity character Apply what nonlinear transformation to `x`?
#' @param ps_link character link function for propensity score DGP, see ?make.link.
#' @param ps_trim numeric This enforces positivity assumption.
#'                  (ps_trim, 1 - ps_trim) will be the bound of generated
#'                  propensity score, implemented by rejection sampling.
#' @param eta_0 numeric Coefficients for the propensity score DGP.
#' @param eta_1 numeric Coefficients for the propensity score DGP.
#' @param eta_2 numeric Coefficients for the propensity score DGP.
#' @param eta_3 numeric Coefficients for the propensity score DGP.
#' @param eta_4 numeric Coefficients for the propensity score DGP.
#'
#' @return
#' data.frame \cr
#' `df` - generated data frame with columns {x1, x2, x2_t, lp, ps, z} \cr
#' `df$x1` - "binary" ~ Bernoulli(0.5), "uniform" ~ U(-sqrt(3)sigma_x, sqrt(3)sigma_x), "normal" ~ N(0, sigma_x^2) \cr
#' `df$x2` - "uniform" ~ U(-sqrt(3)sigma_x, sqrt(3)sigma_x), "normal" ~ N(0, sigma_x^2) \cr
#' `df$x1_t` - "sin": sin(x1), "inv": sign(x1) / (abs(x1) + 1) \cr
#' `df$x2_t` - "sin": sin(x2), "inv": sign(x2) / (abs(x2) + 1) \cr
#' `df$lp` - linear part: `eta_0 + eta_1 * x1 + eta_2 * x2 + eta_3 * x1_t + eta_4 * x2_t` \cr
#' `df$ps` = `stats::make.link(ps_link)$linkinv(eta_0 + eta_1 * x1 + eta_2 * x2 + eta_3 * x1_t + eta_4 * x2_t)` \cr
#' `df$z` - randomized treatment assignment based on the propensity scores.
#' @export
#'
#' @examples
#' set.seed(42)
#' dgp_prop_score(n = 6)
dgp_prop_score <- function(n = 200, x1_dist = "normal", x2_dist = "normal", sigma_x = 1,
                           nonlinearity = "sin", ps_link = "logit", ps_trim = 0.05,
                           eta_0 = 0, eta_1 = 0, eta_2 = 0, eta_3 = 0, eta_4 = 0) {
  # use rejection sampling to generate covariates x1, x2;
  # such that the true propensity score is within (ps_trim, 1 - ps_trim)
  # initialize empty vectors
  x1 <- numeric(0)
  x2 <- numeric(0)
  x1_t <- numeric(0)
  x2_t <- numeric(0)
  while (length(x1) < n) {
    # keep trying
    if (x1_dist == "binary") {
      x1_try <- sample(c(0, 1), n, replace = T)
    } else if (x1_dist == "uniform") {
      x1_try <- stats::runif(n, -sigma_x * sqrt(3), sigma_x * sqrt(3))
    } else if (x1_dist == "normal") {
      x1_try <- stats::rnorm(n, 0, sigma_x)
    } else { # default is normal, in case we need to add other distributions in the future.
      x1_try <- stats::rnorm(n, 0, sigma_x)
    }
    if (x2_dist == "uniform") {
      x2_try <- stats::runif(n, -sigma_x * sqrt(3), sigma_x * sqrt(3))
    } else if (x2_dist == "normal") {
      x2_try <- stats::rnorm(n, 0, sigma_x)
    } else { # default is normal, in case we need to add other distributions in the future.
      x2_try <- stats::rnorm(n, 0, sigma_x)
    }
    if (nonlinearity == "sin") {
      x1_t_try <- sin(x1_try)
      x2_t_try <- sin(x2_try)
    } else if (nonlinearity == "inv") {
      x1_t_try <- sign(x1_try) / (abs(x1_try) + 1)
      x2_t_try <- sign(x2_try) / (abs(x2_try) + 1)
    } else { # default is "sin", ...
      x1_t_try <- sin(x1_try)
      x2_t_try <- sin(x2_try)
    }
    # generate propensity scores
    ps_try <- stats::make.link(ps_link)$linkinv(eta_0 + eta_1 * x1_try + eta_2 * x2_try + eta_3 * x1_t_try + eta_4 * x2_t_try)
    valid_index <- ps_try >= ps_trim & ps_try <= (1 - ps_trim)
    # append valid covariates
    x1 <- c(x1, x1_try[valid_index])
    x2 <- c(x2, x2_try[valid_index])
    x1_t <- c(x1_t, x1_t_try[valid_index])
    x2_t <- c(x2_t, x2_t_try[valid_index])
  }
  # trim covariates to length n
  x1 <- x1[1:n]
  x2 <- x2[1:n]
  x1_t <- x1_t[1:n]
  x2_t <- x2_t[1:n]
  # final propensity scores
  lp <- eta_0 + eta_1 * x1 + eta_2 * x2 + eta_3 * x1_t + eta_4 * x2_t
  ps <- stats::make.link(ps_link)$linkinv(lp)
  # randomized assignment based on ps
  z <- sapply(ps, function(p) {sample(c(1, 0), size = 1, prob = c(p, 1 - p))})
  # return the data frame
  data.frame(x1, x2, x1_t, x2_t, lp, ps, z)
}


